
	//928. Minimize Malware Spread II

//Problem Link:	https://leetcode.com/problems/minimize-malware-spread-ii

int find_set(int i, int parent[]) {
	if (parent[i] == -1) return i;
	return parent[i] = find_set(parent[i], parent);
}

void union_set(int x, int y, int parent[], int rank[]) {
	int s1 = find_set(x, parent);
	int s2 = find_set(y, parent);
	if (s1 != s2) {
		if (rank[s2] <= rank[s1]) {
			parent[s2] = s1;
			rank[s1] += rank[s2];
		} else {
			parent[s1] = s2;
			rank[s2] += rank[s1];
		}
	}
}
int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial)  {
    int n = graph.size();
	int *parent = new int[n];
	int *rank = new int[n];

	fill(parent, parent + n, -1);
	fill(rank, rank + n, 1);
    
    unordered_set<int> s;
    for(auto u:initial){
        s.insert(u);
    }
    
	for (int i = 0; i < graph.size(); i++) {
		for (int j = 0; j < graph[0].size(); j++) {
			if (i != j and graph[i][j] == 1 and !s.count(i) and !s.count(j)) {
				union_set(i, j,parent,rank);
			}
		}
	}
    
    int *infected = new int[n]{};
    unordered_map<int,set<int>> mp;
    for(auto u:initial){
        for(int j = 0;j<n;j++){
            if(graph[u][j] == 1 and u != j and !s.count(j)){
                int p = find_set(j,parent);
                if(!mp[u].count(p)){
                    mp[u].insert(p);
                    infected[p]++;
                }
            }
        }
    }
    
	sort(begin(initial), end(initial));

	int res = initial[0];
	int maximum = 0;

	for (auto u : initial) {
        int total = 0;
        for(auto v:mp[u]){
            if(infected[v] == 1){
                total+=rank[v];
            }
        }
        if(total > maximum){
            res = u;
            maximum = total;
        }
	}
	return res;
}